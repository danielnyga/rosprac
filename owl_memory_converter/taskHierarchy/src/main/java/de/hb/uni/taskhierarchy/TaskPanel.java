/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package de.hb.uni.taskhierarchy;

import de.hb.uni.marcniehaus.owl_memory_converter.tasktree.LogElement;
import de.hb.uni.marcniehaus.owl_memory_converter.tasktree.OWLLogElement;
import de.hb.uni.marcniehaus.owl_memory_converter.tasktree.Task;
import java.util.Collection;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Stack;
import javax.swing.JTree;
import javax.swing.event.TreeModelListener;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreePath;

/**
 *
 * @author marc
 */
public class TaskPanel extends javax.swing.JPanel {

    public TaskPanel() {
        initComponents();
    }
    
    public void setRootTasks(Collection<Task> rootTasks) {
        jTree1.setModel(new DefaultTreeModel(getRootTreeNode(rootTasks)));
        jTable1.setModel(new LogElementTableModel());
        jTree1.addTreeSelectionListener(new TreeSelectionListener() {
            @Override
            public void valueChanged(TreeSelectionEvent e) {
                ((AbstractTableModel) jTable1.getModel()).
                        fireTableDataChanged();
            }
        });
    }
   
    public Search createSearch(String search, Search.SearchType type) {
        return new Search(search, type, jTree1);
    }
    
    public static class Search {
        public enum SearchType {INSTANCE, CLASS, CONTEXT};        
        private Search(String search, Search.SearchType type, JTree tree){
            mSearch = search;
            mType = type;
            mTree = tree;
            mCurrentPosition = ((TreeNode) tree.getModel().
                    getRoot()).preorderEnumeration();
        }
        
        public void next() {
            while(mCurrentPosition.hasMoreElements()) {
                TreeNode current = mCurrentPosition.nextElement();
                if(!(current.logElement instanceof OWLLogElement)) {
                    continue;
                }
                OWLLogElement current_ = (OWLLogElement) current.logElement;
                String currentValue = null;
                switch(mType) {
                    case CLASS: 
                        currentValue = current_.getOwlClassName();
                        break;
                    case INSTANCE:
                        currentValue = current_.getOwlInstanceName();
                        break;                            
                    case CONTEXT:
                        currentValue = current_ instanceof Task ? 
                                ((Task) current_).getContext() : 
                                current_.getOwlClassName();
                        break;                            
                }
                if(mSearch.equals(currentValue)) {
                    mTree.setSelectionPath(new TreePath(current.getPath()));
                    mTree.scrollPathToVisible(new TreePath(current.getPath()));
                    break;
                }
            }
        }
        
        private final Enumeration<TreeNode> mCurrentPosition;
        private final SearchType mType;
        private final String mSearch;
        private final JTree mTree;
    }
   

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        jSplitPane1 = new javax.swing.JSplitPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTree1 = new javax.swing.JTree();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();

        setLayout(new java.awt.GridBagLayout());

        jSplitPane1.setDividerLocation(640);

        jScrollPane1.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
        jScrollPane1.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        jScrollPane1.setViewportView(jTree1);

        jSplitPane1.setLeftComponent(jScrollPane1);

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane3.setViewportView(jTable1);

        jSplitPane1.setRightComponent(jScrollPane3);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        add(jSplitPane1, gridBagConstraints);
    }// </editor-fold>//GEN-END:initComponents

    private TreeNode getRootTreeNode(Collection<Task> rootTasks) {
        LogElement rootElement = new OWLLogElement();
        HashMap<String, Collection<LogElement> > taskMap = new HashMap<>();
        rootElement.setOtherObjectProperties(taskMap);
        taskMap.put("rootTask", new LinkedList<LogElement>(rootTasks));
        TreeNode rootNode = new TreeNode("/", rootElement);
        addChildren(rootNode);
        return rootNode;
    }
    
    
    private void addChildren(TreeNode t) {
        Map<String, Collection<LogElement> > children = 
                t.logElement.getOtherObjectProperties();
        for(String key : children.keySet()) {
            for(LogElement e : children.get(key)) {
                TreeNode child = new TreeNode(key, e);
                t.add(child);
                addChildren(child);
            }
        }
    }
 
    private class TreeNode extends DefaultMutableTreeNode {
        public TreeNode(String role, LogElement element) {
            this.role = role;
            this.logElement = element;
        }

        @Override            
        public String toString() {
            return "["+role+"] "+logElement.toString();
        }            

        LogElement logElement;
        private final String role;
    }        
        
    private class LogElementTableModel extends AbstractTableModel {

        @Override
        public int getRowCount() {                
            TreePath path = jTree1.getSelectionPath();            
            if(path==null) {
                return 0;
            }
            Map<String, Collection<String> > selectedElements = 
                    ((TreeNode) path.getLastPathComponent()).
                            logElement.getOtherDataProperties();
            int elements=0;
            for(String key : selectedElements.keySet()) {
                for(String value : selectedElements.get(key)) {
                    elements++;
                }
            }
            return elements;
        }

        @Override
        public Object getValueAt(int row, int column) {
            TreeNode node = (TreeNode) 
                    jTree1.getSelectionPath().getLastPathComponent();
            if(node==null) {
                throw new UnsupportedOperationException();
            }
            Map<String, Collection<String> > selectedElements = 
                    node.logElement.getOtherDataProperties();
            int currentRow=0;
            for(String key : selectedElements.keySet()) {
                for(String value : selectedElements.get(key)) {
                    if(currentRow==row) {
                        return column==0 ? key : value;
                    }
                    currentRow++;
                }
            }
            return "";
        }

        @Override
        public String getColumnName(int i) {
            return i==0 ? "Property" : i==1 ? "Value" : "";
        }

        @Override
        public int getColumnCount() {
            return 2;
        }

        @Override
        public boolean isCellEditable(int i, int i1) {
            return false;
        }        
    }
    

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JTable jTable1;
    private javax.swing.JTree jTree1;
    // End of variables declaration//GEN-END:variables
}
